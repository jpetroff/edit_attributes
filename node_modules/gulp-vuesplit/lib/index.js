"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContentFromNode = getContentFromNode;
exports.cleanTemplateText = cleanTemplateText;
exports.generateHash = generateHash;
exports.generateScopedName = generateScopedName;
exports.generateScopedNameFilename = generateScopedNameFilename;
exports.default = vueSplitPlugin;

var _through = require("through2");

var _through2 = _interopRequireDefault(_through);

var _parse = require("parse5");

var _parse2 = _interopRequireDefault(_parse);

var _deIndent = require("de-indent");

var _deIndent2 = _interopRequireDefault(_deIndent);

var _vinyl = require("vinyl");

var _vinyl2 = _interopRequireDefault(_vinyl);

var _postcss = require("postcss");

var _postcss2 = _interopRequireDefault(_postcss);

var _series = require("async/series");

var _series2 = _interopRequireDefault(_series);

var _posthtml = require("posthtml");

var _posthtml2 = _interopRequireDefault(_posthtml);

var _postcssModules = require("postcss-modules");

var _postcssModules2 = _interopRequireDefault(_postcssModules);

var _vueTemplateValidator = require("vue-template-validator");

var _vueTemplateValidator2 = _interopRequireDefault(_vueTemplateValidator);

var _htmlMinifier = require("html-minifier");

var _htmlMinifier2 = _interopRequireDefault(_htmlMinifier);

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _get = require("lodash/get");

var _get2 = _interopRequireDefault(_get);

var _posthtmlAttrsParser = require("posthtml-attrs-parser");

var _posthtmlAttrsParser2 = _interopRequireDefault(_posthtmlAttrsParser);

var _crc = require("crc");

var _crc2 = _interopRequireDefault(_crc);

var _gulpUtil = require("gulp-util");

var _gulpUtil2 = _interopRequireDefault(_gulpUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var memCache = {
  css: {},
  html: {},
  js: {}
}; /*
   ===============================================================================
     Gulp Vue-Split
     Copyright 2016 Sebastian Software GmbH <https://www.sebastian-software.de>
   ===============================================================================
   */

function getCssClassName(moduleMapping, cssModuleName) {
  var cssClassName = (0, _get2.default)(moduleMapping, cssModuleName);
  if (!cssClassName) throw new Error("CSS module " + cssModuleName + " is not found");

  if (typeof cssClassName !== "string") throw new Error("CSS module " + cssModuleName + " is not a string");

  return cssClassName;
}

function posthtmlCssModules(moduleMapping) {
  return function (tree) {
    tree.match({ attrs: { "css-module": /\w+/ } }, function (node) {
      var attrs = (0, _posthtmlAttrsParser2.default)(node.attrs);
      var cssModuleName = attrs["css-module"];
      delete attrs["css-module"];

      attrs.class = attrs.class || [];
      attrs.class.push(getCssClassName(moduleMapping, cssModuleName));
      node.attrs = attrs.compose();

      return node;
    });
  };
}

var templateMinifyOptions = {
  collapseWhitespace: true,
  removeComments: true,
  collapseBooleanAttributes: true,
  removeAttributeQuotes: true,
  useShortDoctype: true,
  removeEmptyAttributes: true,
  removeOptionalTags: true
};

function getContentFromNode(node) {
  var content = (0, _deIndent2.default)(_parse2.default.serialize(node.content || node)).trim();
  return content ? content + "\n" : content;
}

function convertFragmentIntoNodeMap(fragment) {
  var nodes = {};
  fragment.childNodes.forEach(function (child) {
    // Ignore text (typically just white space) and comment nodes
    if (child.nodeName === "#text" || child.nodeName === "#comment") return;

    var content = getContentFromNode(child);
    nodes[child.nodeName] = content;
  });

  return nodes;
}

function cleanTemplateText(text) {
  return text.split("\n").map(function (line) {
    return line.trim();
  }).join("\n");
}

function generateHash(filename) {
  var relPath = _path2.default.relative(process.cwd(), filename);
  return _crc2.default.crc32(relPath).toString(16);
}

function generateScopedName(name, filename) {
  return name + "-" + generateHash(filename);
}

function generateScopedNameFilename(name, filename) {
  return _path2.default.basename(filename).split('.')[0] + "-" + name;
}

function vueSplitPlugin() {
  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var moduleMapping = null;

  function processStyle(done, text, path, base) {
    if (!text) return done();

    var scopeNameFn = generateScopedName;

    if (config.cssFilenameScoped) {
      scopeNameFn = generateScopedNameFilename;
    }

    return (0, _postcss2.default)([(0, _postcssModules2.default)({
      generateScopedName: scopeNameFn,
      getJSON: function getJSON(cssFileName, json) {
        moduleMapping = json;
      }
    })]).process(text, {
      from: path
    }).then(function (result) {
      if (memCache.css[path] === result.css) return done();

      memCache.css[path] = result.css;

      var cssObj = new _vinyl2.default({
        contents: new Buffer(result.css),
        path: path.replace(".vue", ".css"),
        base: base
      });

      return done(null, cssObj);
    });
  }

  var minifyTemplate = true;

  function processTemplate(done, text, path, base) {
    if (!text) return done();

    var warnings = (0, _vueTemplateValidator2.default)(text);
    warnings.forEach(function (msg) {
      /* eslint no-console: 0 */
      console.warn(msg);
    });

    return (0, _posthtml2.default)([posthtmlCssModules(moduleMapping)]).process(text).then(function (result) {
      if (memCache.html[path] === result.html) return done();

      memCache.html[path] = result.html;

      try {
        var html = minifyTemplate ? _htmlMinifier2.default.minify(result.html, templateMinifyOptions) : cleanTemplateText(result.html);

        new _vinyl2.default({
          contents: new Buffer(html),
          path: path.replace(".vue", ".html")
        });
      } catch (exc) {
        console.error("Problem during template processing: " + exc);
        return done(exc);
      }

      var jsHeader = "/* Generated by gulp-vuesplit - Edit the vue file instead. */\n/* eslint-disable */\n";
      var jsModule = jsHeader + "export default " + JSON.stringify(html);
      var jsObj = new _vinyl2.default({
        contents: new Buffer(jsModule),
        path: path.replace(".vue", ".html.js"),
        base: base
      });

      return done(null, jsObj);
    });
  }

  function processScript(done, text, path, base) {
    if (!text) return done();

    if (memCache.js[path] === text) return done();

    memCache.js[path] = text;

    var fileObj = new _vinyl2.default({
      contents: new Buffer(text),
      path: path.replace(".vue", ".js"),
      base: base
    });

    return done(null, fileObj);
  }

  function processHash(done, path, base) {
    var text = JSON.stringify({
      hash: generateHash(path)
    });

    var fileObj = new _vinyl2.default({
      contents: new Buffer(text),
      path: path.replace(".vue", ".json"),
      base: base
    });

    return done(null, fileObj);
  }

  function transform(file, encoding, callback) {
    /* eslint no-invalid-this: 0 */

    if (file.isNull()) return callback(null, file);

    if (file.isStream()) return callback(new _gulpUtil2.default.PluginError("gulp-vuesplit", "Streams are not supported"));

    var content = file.contents.toString("utf8");
    var fragment = _parse2.default.parseFragment(content, {
      locationInfo: true
    });

    var nodes = convertFragmentIntoNodeMap(fragment);
    var self = this;
    var filePath = file.path;
    var fileBase = file.base;

    return (0, _series2.default)([function (done) {
      processStyle(done, nodes.style, filePath, fileBase);
    }, function (done) {
      processTemplate(done, nodes.template, filePath, fileBase);
    }, function (done) {
      processScript(done, nodes.script, filePath, fileBase);
    }, function (done) {
      processHash(done, filePath, fileBase);
    }], function (err, results) {
      if (err) return callback(new _gulpUtil2.default.PluginError("gulp-vuesplit", err));

      results.forEach(function (resultFile) {
        return resultFile && self.push(resultFile);
      });
      return callback();
    });
  }

  return _through2.default.obj(transform);
}
//# sourceMappingURL=index.js.map